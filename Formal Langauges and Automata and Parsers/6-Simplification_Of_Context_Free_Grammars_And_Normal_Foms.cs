using System;

namespace Formal_Languages_And_Automata
{
    public class Simplification_Of_Context_Free_Grammars_And_Normal_Foms
    {
        //public enum Context Free Grammar Normal Form Properties { since de3finitoin of context-free grammars imposes no restriction on right side of profuctions but we know that complete freedom is not necessary and some restrcitions like removing some productions such as lambda and unit make grammar easiereven in some instances its desirable to place more stringent restrictions on the grammar so we need methods to transform a context free grammar into an equivalent one satisfying certain restrictions on its form its investigated as normal forms for context-free languages,a normal form is one that although restricted is broad enough so that any grammar has an equivalent normal form version ,>>>>there are two forms that are most useful,the Chomsky normal form and the Greibach normal form>>>> if L be any linear language not containing lambda then there exist a grammar G= (V, T, S, P) with all of its productions have one of the forms: A  ->  aB, A  ->  Ba, A ->  a where a is in T, A,B are in V such that L=L (G),>>>> for every context-free grammar G=(V, T, S, P) there is an equivalent one in which all productions have the form A  ->  aBC or A  ->  lambda where a is in Zigma union {lambda} , A,B,C, are in V};
        //public enum Lambda Free Languages Properties {  empty string pays a rather singular role in theorems and proofs so we give it special attention and we prefer to remove it from consideration and looking at languages without Lambda in doing so we dont lose generality since if L be any context free language and G=(V,T,S,P) is a context free grammar for L - {lambda} then the grammar we obtain by adding to V the new variable S0 making S0 the start variable and adding to P, S0 -> S|Lambda  generates L,>>>>there is no difference between context free languages that include lambda and those that do not and any conclusion made for L-{Lambda} transfers to L and also for any context free grammar G there is a method for obtaining Bbar such that L(Gbar)=L(G) -{Lambda} };
        //public enum Grammar Substitution Rule Properties { many rules govern generating equivalent grammars by means of substitution, its one that is useful for simplifying grammarsin various ways,let G=(V,T,S,P) is context free and contains production A -> x1Bx2 and with assumtion that A and B are different variables and B -> y1|y2...|yn set of all productions in P having B as the left side,let Gbar=(V,T,S,Pbar) is a grammar in which Pbar is constructed so that if we delete A->x1Bx2 and add A -> x1y1x2|x1x2x2|...|x1ynx2 to it then L(Gp)= L(G) to prove it we have that if derivation s=>*G w involves production A->x1Bx2 then S=>* Gbar w  if it involves A->x1Bx2 then look at the derivation that that prodctuin was used for first time then that introduced B has to be replaced we can assume its done immediately so we can reach the same result from with G and Gbarif A->x1Bx2 is used again later we repeat the argument and we can use induction on number of times the production is applied conclude that S=>Gbar w so if w is in L(G) then w is in L(Gbar) so in result substitutaion rule is that we replace A->x1Bx2 by putting in its place set of productions in which B is replaced by all strings it derives in one step };
        //public enum Useful Grammar Variables Properties { let G=(V,T,S,P) be a context free grammar, A  that is an element of V  is useful if and only if there is at least one w element of L(G) such that S =>* xAy =>*w with x and y in (V union T)* in words variable is useful if and only if it occurs in at least one derivation };
        //public enum Useless Grammar Variable Properties { a variable that is not useful,a production is useless if it involves any useless variable,>>>> variable is useless if there is no way of getting a terminal string from it To do this we should look at variables then see that if they reach terminals or not,meaning that ,that variable although can occur in a string derivation but this can never lead to a sentence also variable is useless if there is no way to achieve it meaning that it cant be reached from the start symbol to do this we draw a dependency graph for variables if there is a path from the vertex labled S to the vertex with that variable,So after identifying these useless variables we remove it and its affected productions and terminals.  };
        //public enum Dependency Graph Properties { its a way of visualizing complex relationships and are found in many applications,>>>>for context free grammars it has its vertex labled with variables with an edge between vertices C and D if and only if there is a production form C -> xDy };
        //public enum Lambda Grammar Production Properties{ any production of a context free grammar of the form A -> lambda,is called a lambda production and is sometimes undesireable,>>>>3.	A grammar may generate a language not containing  7 have some Lambda- productions or null able variables in such cases the Lambda- productions con be removed};
        //public enum Nullable Grammar Variable Properties { any variable A for which the derivation A =*> lambda is possible,is called nullable };
        //public enum Unit Grammar Production Properties{any production of a context free grammar of the form A -> B,where A,B are in V is called a unit-production and are at times desirable};
        //public enum Grammar Simplification Properties { what we mean by it is the removal of certain types of undesirable productions and this process doesnt result in an actual reduction of number of rules,>>>> if G = (V, T, S, P) is a context-free grammar and has production of the form A  ->  xy , where x,y in (V,T)+, if this rule is replaced by A  ->  By, B  -> x, where B isn't in V then the resulting grammar is equivalent to the original one.,>>>> the removal of useless productions always reduce the grammar complexity also we have that removal of useless productions does not necessarily produce a minimal grammar,>>>>let G- (V,T,S,P) be a context-free grammar divide the set of productions whose let sides are same gives variable into two disjoint subject: A  ->  Ax, |Axc|…|AXn, A  ->  y1|yc|…|ym where xi,yi are in (U T) but A isn't a prefix of any yi consider grammar G= (V Union {2},T,S,P) where 2 isn't in V, and P is obtained by replacing all productions having A on left by A  -> yi|yj Z, i=1,2,…,m , z -> xi|xiz,j=1,2,…,n then we have that L(G)= L(G) also we have that theorem: assume that set of productions having A on the left be divided into two disjoint subject: A -> x1A|x2A|….|xnA and A -> t1|y2|…|ym where A is not a suffix of any yi then the grammar obtained by replacing these productions with A -> yi|Zyi,j=1,2,...,n. is equivalent to original one    };
        //public enum Grammar Complexity Properies {Its possible to define the term simplification precisely by introducing the concept of the complexity of a grammar this can be done in many ways, one way is through the length of all strings giving the production rules complexity ,for examle we might use G =zigma(A->v in p) {1 + |v|}length of left of productions for all productions };
        //public enum Minimal Grammar Properties { A context-free grammar G is minimal for a given language L if complexity(G) <= complexity (Gbar) for any Gbar generating L };
        //public enum Chomsky Normal Form Properties {a context-free grammar is in chomsy form if all productions are of the form A -> BC or A to a where A B C are in V and a is in T,its so that number of symbols on the right of production is strictly limited meaning that the string on the right of a production consist of no more than two symbols. ,>>>>if G be a context free grammar without any lambda productions or unit productions and k be the maximum number of symbols on the right of any production P there is an equivalent grammar in chomsky normal form with bo more than (k - 1) * | P| + |T| };
        //public enum Greibach Normal Form Properties { a contex-free grammar G is in Griebach normal form if all productions are of the form A -> ax where a is an element of T and x an element of V*Here we put restrictions not on length of right sides of productions but on the positions in which terminals and variables can appear ,>>>> arguments justifying ,Greibach normal form are a little complicated and not very transparent also constructing a grammar that is in that form is tedious so we deal with it briefly also this form has many thechical and practical consequences, also we know that if we compare this form and s-grammar we see that A ax is common to both of them but Griebach form doesn't have the restriction that pair (A,a) occur at most once so this freedom gives a generality to this form not possessed by s-grammars if a grammar is not in Greibach normal form, we can rewrite it in this form with some of techniques such as using substitution of a smaller a production in bigger production or introducing variables for single terminals and substituting terminal with their associated variable so that we obtain Greibaoh form so we have this general result: theorem: for every context-free grammar G with 7 not in L(G) there exists an equivalent grammar G in Greibach normal form };
        //public enum Two Standard Form Normal Form Properties { a contex-freegrammar is in two standard form, if all productions satisfy following pattern A -> aBC and A -> aB and A ->a, A B C are in V where a and a an element of T,>>>>two atNDrd form is general ,for any context freee grammar G with lambda notin L(G) there exists an equivalent grammar in two-standard form };
        //Public enum Useless Production Removing Algorithm Properties{ its general construction is expressed by this theorem Theorem let G= (V, T, S, P) is a context free grammar then there exists an equivalent grammar G= (V, T, S, P) that doesn't contain any useless variables or productions to prove it we have that grammar G can be generated from G by an algorithm consistency of two parts in first part we construct an intermediate grammar G1= (V1,T2,S,P1) so that V1 contains variables like A such that A -*> w is in T,is possible. The steps in algorithm are: 1-Set V1 to Empty set,2- Repeat following step until no more variables are added to V1. For every A in V so that P has production of form A->x1x2…xn , with all in V1 Union T, add A to V1 3-Take P1 as all productions in P whose symbols are all in (V1 U T) this procedure clearly terminates and also we have that if A is in V1, then A->w is in T is it’s a possible derivation, we only need to show that whether every A so that we have A ->w =ab… is added to V1 before procedure terminates, to do this consider every such A, and its corresponding partial derivation tree, at its level k we have only terminals, so every variable A: on level k-1 is added to V1 on first pass through step2 of algorithm, any variable at level k-2 is added to V1 on second pass of step2 algorithm, on level k-3 are added to V1 on third pass of step2 algorithm so algorithm cant terminate while there are variables in tree not yet in V1 so A will eventually be added to V1, in second part of algorithm we get final answer G from G, we draw variable dependency graph for G and from it find any variable that can be read from S then removing them from variable set and also production involving them we also can eliminate terminals not occurring in some useful production the result is G= (V,T,S,P). so G doesn't contain any useless grammar or productions and also we have for each W in L (G) S=*> xAy=*> W then since the construction of G retains A and its associated productions we have everything needed to make derivation S=*> x Ay =*> W since G is constructed from G by removal of productions so P is proper subset of P & L(G) is proper subset of L(G) so putting two results together we conclude that G=G.};
        //public enum Lambda Production Removing Algorithm Properties{ it substitutes for Lamda-productions as expressed by this theorem theorem: let G be a context- free grammar with lambda not in L(G), then there exists an equivalent grammar G having no  -productions A->Lambda put A in V2. Repeat following steps: 1. For all productions A-> Lambda put A in Vn: for all production -> A1 A2… An, where A1, A2,…, An are in Vn, put B into Vn when set Vn has been constructed to build P we consider productions of from A ->x1 x2 … xm, m>=1 where each x1 is in V union T for each such production we put in P that production as well as those generated by replacing nullable variables with lambda in all possible combinations e.g.  if xi and xj are nullable xi is lambda xi isn't, xi is xi isn't, xi and xi and xi are, there is one exception if all xi are nullable, the production A -> lambda is not put into P so G is equivalent to G};
        //public enum Unit Production Removing Properites{ to remove unit productions we use substitution rule this can be done if we proceed with some care as expressed by this theorem, theorem: let G = (V, T, S, P) be a context-free grammar without lambda-productions then there exists a context- free grammar G= (V, T, S, P) not having any unit-production and is equivalent to G. to prove it we have that obviously any unit- production of form A -> can be removed from grammar without effect so we only consider A -> B where A and B are different variables first it seems that we can use theorem for removing lambda productions with x1= x2 = lambda to replace A  ->  B with A  ->  y1|y2|yn but this doesn't always work in special case A  ->  B, B  -> A the unit production are not removed to get around this we first find for each A all variables B such that A  ->  B we can do this by drawing a dependency graph so this relation holds whenever there is a walk between A and B, the new grammar G is generated by first putting into P all non- unit productions of P, next for all A and B satisfying A  ->  B we add to P, A -> y1|y2|…|yn where B  ->  y1|y2|…|yn is set of all rules in P with B on the left note since we toke B -> y1|y2|…|yn from P, none of y: can be a single variable so no unit productions are created by last step so the resulting grammar is equivalent to original one};
        //publice enum Grammar Simplification Algorithm Properties{ by this algorithm we show that grammars for context- free languages can be made free of useless productions, lambda-productions and unit-productions, we express this algorithm by this theorem theorems let L be a context-free language not having lambda then there exists a context- free grammar generating L and does not have any useless productions, lambda-productions, or unit productions to prove it we have that algorithm for removing corresponding productions, removes them we only should be careful that the removal of one type of production may produce productions of another type e.g. removal of lambda-productions can create new unit productions, also algorithm for removing unit productions requires that the grammar have no lambda-productions but we have that removal of unit productions does not create lambda- productions and removal of useless productions does not create lambda- productions or unit-productions so we can remove all desirable productions using following sequence of steps: 1. Remove lambda-productions 2. Remove unit- productions 3. Remove useless productions};
        //public enum Chosmky Convertor  Algorithm Properties{ its expressed by this theorem theorem: any context- free grammar G= (V,T,S,P) with lambda not in L (G) has an equivalent grammar G= (V,T,S,P) in Chomsky form to prove it we have that we can assume without loss of generality that G has no lambda- productions and no unit-productions the construction of G will be done in two step: step1: construct a grammar G1= (V1,T,S,P1) from G by considering all productions in P in the form A  -> x1x2,…xn, where each xi is a symbal either in V or in T , if n=1 then is a terminal since we have no unit-production in this case put the production into p1 if n 2 introduce new variables for each a in T for each production of P in form A ->x1x2…xn we put in P1 the production A -> C1C2…Cn where Ci=Xi if xi is in V and Ci= Ba if xi=a for every Ba we also put into P1 the production Ba  -> a so removing all terminals from productions whose right side has length of greater one replacing them with newly introduced variables at the end of this step we have a grammar G1 with productions A  ->  -> a and A  -> C1C2…Cn, where Ci is in V1, it’s easy to see that L (G1)=L(G) step 2: in the second step we introduce additional variables to reduce length of right sides of productions where necessary , first we put all productions of form A  ->  a as well as of form A  -> C1 C2… Cn with n=2 into P, for n>2 we introduce new variables D1, D2,… and put into P the productions A  ->  C1D1, D1  -> C2D2,…,Dn-2  ->  Cn-1Cn, obviously the resulting grammar G is in Chomsky normal form and also we have that L(G) =L(G).};
         //public enum CYK  Algorithm Properties { it’s an membership algorithm for context-free grammars requiring approximately |w| steps to parse string w, this algorithm is called CYK after its originators J.cocke, D.H. Younger ond T.Kasami. it works only if the grammar is in Chomsky normal form and succeeds by breaking one problem into a sequence of smaller ones in the following way assume we have a grammar G=(V, T, S, P) in Chomsky normal form and a string w=a1a2…an, we define substrings wij=ai…aj, and subsets of V, Vij={A in V: A  ->  wij} clearly w is in L (G) iff S is in V1n, to compute Vij we know that since A is in Vi j iff G contains a production A -> lj so Vij can be computed for all 1 i n by inspection of w and productions of the grammar, if j>I A derives wij iff there is a production A  -> BC with B  ->  wik and C  ->  wk+1 j for some k with i k, k<j in other words Vij= union k in {i,i+1,…,j-1}, {A: A  -> BC, with B in Vik, C in Vk+1,j} so to compute Vij by this equation we proceed the sequence: 1. Compute V11,V22,…,Vnn.2. Compute V12, V23, …, V(n-1)n… 3. Compute V13.V24,…, V(n-2)n and so on ,>>>> we can convert this algorithm to a parsing method by some additions to keep track of how the element> of Vij are derived , >>>> to analyze its running time we have that exactly n(n+1)/2 set s of Vij have to be computed each involves evolution of at most n terms in main equation for computing Vij so it requires O(n) steps.};

    }
}
