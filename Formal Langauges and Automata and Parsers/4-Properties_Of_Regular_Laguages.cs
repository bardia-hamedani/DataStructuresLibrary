using System;

namespace Formal_Languages_And_Automata
{
    public class Properties_Of_Regular_Laguages
    {
        //public enum Regular Language Closure Properties { when performing operations on regular languages is it regular yet,>>>>a family of regular languages can be closed under some operation on languages,>>>>to see the closure of regular languages under common set operations such as union and intersection we have this theorem Theorem:if L1 and L2 are regular languages then so are L1 union L2,L1 intersect L2,L1L2,L1bar and L1*we say family of regular languages is closed under union,intersection,concatenation,complementation,and star-closure to prove it we have that if L1 and L2 are regular then we have regular expressiosn r1 and r2 such that L1=L(r1) and L2=L(r2) since r1+r2,r1r2,and r1* are regular expressions soL1 union L2,L1L2,and L1* are ergular so closure under union,concatenation,and star-closure is immediate to show closure under complementation let M=(Q,Zigma,zigma,q0,F) be a dfa accepting L1 then dfa Mbar=(Q,Zigma,zigma,q0,Q-F) accpets L1bar note that in this dfa definition we assumed zigma* to be a total function so that zigma*(q0,w) is defined for all w in Zigma* to demostrate clusore under intersection let L1=L(M1) and L2=L(M2) where M1=(Q,Zigma,zigma1,q0,F1) and M2=(P,Zigma,zigma2,p0,F2) are dfas we construct from M1 and M2 a combined autmaton Mbar=(Qbar,Zigma,zigmabar,(q0,p0),Fbar) wose set state Qbar=Q*P conisists of pairs (qi,pj) and its transition function zigmabar is so that Mbar is in state (qi,pj) whenever M1 is in state qi and M2 is in state pj its acheved by taking zigmabar((qi,pj),a)=(qk,pl) whenever zigma1(qi,a)=qk and zigma(pj,a)=pl Fbar is defined as set of all (qi,pj) such that qi in F1 and pj in F2 so w in L1 intersect L2 iff its accpeted by Mbar so L1 intersect L2 is regular and its closed under it to see closure under reversal we have ///……..//directions on each edge since this modified nfa accepts w^R then original nfa accepts w so original nfaaccpets L^R so proving colusre under reversal};
        //public enum Constrcuctive_Theorem_Proof_Properties { it not only establish the result but also ahows explicitly how to construct it they are important since they give us insight into the results and often serve as strating point for practical algorithm };
        //public enum Regular Language Decidibility Properties { whether a language has certain properties or not };



        //public enum Language Homomorphic Image Properties {suppose Zigma and Gamma are alphabets then function h:Zigma->Gamma* is called a homomorphism in other words its a subtitution in which a single letter is replaced with a string domain of function h is strings if w=a1a2…an then h(w)=h(a1)h(a2)…h(an) so if L is a language on Zigma then homomorphic image is defiend as h(L)={h(w):w in L}a,>>>>the family of regular languages is closed under arbitrary homomorphism};
        //public enum Language Right Quotient Properties {let L1 and L2 be languages on same alphabhet then right quotient of L1 with L2 is defined as (1)L1/L2={ x:xy in L1 for some y in L2 } L1 right quotient L2 is formed by taking all strings in L1 that have a suffix belonging to L2 every such string after removal of this suffix belongs to L1/L2,>>>> to find L1/L2 we modify M its automaton so thatit accpets x if there is some y such that satisfies (1) so to answer it we must find whether there is some y such that xy is an element of L1 and y is an element of L2 for each q in Q to do it we see whether there is a walk to a final state with walk labled v an element of L2 then any x such that zigma(q0,x) = q will be in L1/L2 we modify the automaton accordingly to make q a final state,>>>> L1=L1L2/L2 not true for all languages L1 and L2,>>>> the family of regular languages is closed under right quotient with regular language to prove it we have this theorem:if L1 and L2 are regular languages then L1/L2 is also regular we say that family of regular languages is closed under right quotient with a regular language to prove it assume that L1=L(M) where M=(Q,Zigma,zigma,q0,F) is a dfa we construct another dfa Mbar=(Q,Zigma,zigma,q0,Fbar) as follows for each qi in Q determine if there exists a y in L2 such that zigma*(qi,y)=qf in F this can be done by looking at dfa`s Mi=(Q,Zigma,zigma,qi,G,F) the automaton Mi is M with initial state q0 is replaced by qi then we determine whether there exists a y in L(Mi) that is also in L2 to do so we use intersection of regular languages to find transition graph for L2 intersect L(Mi) if there is a path from its initial state to final state L2 intersect L(Mi) isnt empty in that case add qi to Fbar repeating this for every qi in Q we determine Fbar and so contruct Mbar now to prove that L(Mbar)=L1/L2 let x be any elelment of L1/L2 then we have y in L2 such that xy in L1 this implies that zigma*(q0,xy) in F so that there must be some q in Q such that zigma*(q0,x)=q and zigma*(q,y) in F so q is in Fbar and Mbar accepts x since zigma*(q0,x) is in Fbar convesly for any x accepted by Mbar we have zigma*(q0,x)=q in Fbar this implies that there exists a y in L2 such that zigma*(q,y) is in F so xy is in L1 and x isin L1/L2 and so L(Mbar)=L1/L2 so L1/L2 is regular };
        //public enum Membership Problem Properties { given a language and a string w can we determine whether or not w is an elemnt of L,>>>very little can be done with languages for which we cant find efficient membership algorithms  };
        //public enum Regular Languages Pigeonhole Principle Properties {Its used by mathematicians to refer to following observation if we put n objects into m boxes and if n>m then at least one box must have more one item in it, >>>> we can use it to show than if a language is regular so that e.g. we see that we can see that  we can produce unlimited number of states but we have only finite states so we can find other final state other than its original final state by replacing q0 with q and producing final state with a incorrect input so it contradicts with assumption of regularity so it is not regular,>>>> to use this type of argument in different situations we codify it as a general theorem there are many ways to do it, pumping lemma is one of its famous ones. pigeonhole principle is just a way of stating unambigously what we mean when we say that a finite automaton has a limited memory,>>>>is used to show that cetrain languages are not regular };
        //public enum Regular Languages Pumping Lemma Properties { It uses the pigeonhole principle in another form using the observation that in a transition graph with n vertices any walk of length n or longer must repeat some vertex that is contain a cycle, and it is expressed as a theorem Theorem: if L is an infinite regular language then there exists some positive integer m such that any w in L with W >= m can be decompesed as w = xyz with |xy| <= m and |y| >=1 such that wi = x.y ^ i.z is also in L for all i=0 1 2 etc To paraphrase this every sufficiently long string in L can be broken into three parts so that an arbitrary number of repetitions of the middle part yields another string in L we say that the middle string is pumped hence the term pumping lemma for this result to prove it we have that since L is regular it has a dfa if dfa have q0,…,qn then we take a string w so that |w| >=m= n+1 since L is infinite its possible if automaton goes through states q0,q1,…,qf  as it processes w then since sequence have |w| +1 entries at least one state will be repeated and this repetition must start no later than the nth move so the sequence is like q0,q1,…,qr,….,qr,….qf,  indicating there must be substring, x, y, z of w so that zigma(q,x) = qr, zigma(qr,y)=qr,zigma(qr,z)=qf with |xy|<= x+1=m and |y|>=1 so we have zigma(q0,xz)=qf as well as zigma(q0,xyz)=qf,zigma(q0,xy^3z)=qf  so theorem is proved,>>>> pumping lemma is only for finite languages although a finite language be regular it can't be pumped since pumping creates an infinite set the theorem holds for finite languages but it is vacuous since m in pumping lemma is to be taken lager than the longest story no string can be pumped the pumping lemma like pigeonhole argument is used to show that cetrain languages are not regular,   the demonstration is always by contradiction there is nothing in the pumping lemma as its stated to prove that a language is regular even we show that any pumped string must he in the original language there is nothing in theorem that allow us to conclude that language is regular ,>>>> to use this theorem first we assume that a language regular and pumping lemma holds then we choose w, m, y and z and by using assumptions about |xy|<m & |y|>=l & w=xyz we choose |xy|&|y| then create w e.g. w0 and see that it’s in L if isn't then L isn't regular so we keep in mind what the theorem says we are guaranteed the existence of an m decomposition xyz but we don't know what they are,>>>>we cannot claim contradiction cuz thepumping lemma is violated for some specific values of m or xyz but pummping lemma holds for every w in L and every i therefore if the pumping lemma is violated even for one w or i then language isnt regular,>>>>correct argument can be visualized as a game (1) opponent picks m ,(2) given m we pick a string w in L with |w|>=m we are free to choose any w that w is in L and |w| >= m we can choose w forcing a choice of x y and z tha produces cantradiction ,(3) opponent chooses decomposiiotn xyz ,|xy|<=m l and |y|>=1 such that make difficult for us to win the game ,(4) we pick i in such way that the pumped string w is not in L,if we can do this sowe win the game,our goal is to win the game by establishing a contradiction of pumping lemma while opponent tries to fool us so if we win the language isn't regular step2 is crucial while we can't force opponent particular decomposition of we can pick w so that the opponent is very restricted in step 3 forcing a choice of x,y & z that allows as to produce a violation of 2 pumping lemma in our next move if we choose w too short or isn't suitable related to nature of language also we have that to apply the pumping lemma we can't assume that the opponent make a wrong move also we can see how x, y and z con be chosen by opponent at based on chosen w and also we can exclude x,y or z if one of them doesn't change the result then we see that if we choose any y or x we can give a contradicting i then language won’t be regular also after presenting an I for contradiction we can use language definition to show that w isn't in L, >>>> in some cases closure properties can be used to relate a given problem to one we have already classified it may be simpler than a direct application of pumping lemma e.g. we use closure under homomorphism to change the language to one that we have moved its not regular so our first language isn't regular also to produce contradiction we can choose w so that choosing a contradicting c in last step is considered also if we can produce some previously proved nonregular languages from our target language we can prove it's nonegularity, a mistake in using this theorem is to start with a string not in L e.g. when we want to choose a w it should be in language L otherwise the argument is incorrect also the most common mistake is making assumption about decomposition xyz the only thing we can say about xyz is what the pumping lemma namely that y isn't empty and |xy|<=m that is y must be within m symbols of the left end of string anything else makes the argument incorrect e.g. when we assign y we should tell that one of its variables is odd and then w has a property so L isn't regular so in using pumping lemma although we should know its rules we should have also argued strategy to win,>>>> there is another version of pumping lemma so that if L is regular then there is an m so that every w in L of length greater than m can be decomposed as w=xyz, with |yz|<=m and |y|>=1 so that xyz is in L for all I, >>>> it’s another version of pumping lemma if L is regular every then there exists an m so that the following holds for sufficiently long w in L and every one of its decompositions w=u1vu2 with u1,u2 in Zigma,|v|>=m the middle string v can be written as v=xyz with |xy|<=m ,|y|>=1 such that u1 x(y^i)z u2 in L for all i=0,1,2,…};
    }
}
