using System;

namespace Formal_Languages_And_Automata
{
    public class A_Hierarchy_Of_Formal_Languages_And_Automata
    {
        //public enum Unrestricted Grammars Properties { in grammars,we told that their production rules can take any form but then we imposed some restrictions to get specific grammar types,if we take the general form of the grammar and impose no restrictions,we get unrestricted grammars as expressed by this definition:a grammar G=(V,T,S,P) is called unrestricted if all the productions are of the form u -> v, where u is in (V union T)+ and v is in (V union T)*,so we see that no conditions are imposed on the productions so that any number of variables and terminals can be on left or right in any order,with only one restriction:Lambda is not allowed as the left side of a production,>>>>the unrestricted grammars are much more powerful than restricted forms like regular and context-free grammars,and they correspond to the largerst family of languages that can be recognized by mechanical means.that is unrestricted grammars generate exactly the family of recursively enumerable languages.its shown in two parts,first expressed by this theorem Theorem:any language generated by an unrestricted grammar is recursively enumerable,to prove it we have that,our considered grammar defines procedure for enumerating all strings in the language systematically,e.g. we can list all w in Lthat is derivied in one step such that s=>w.since the set of the productions of the grammar is finite,,there will be a finite number of such strings.next we list all w in L that can be dirived in two steps S=>x=>w and so on.we can simulate these derivations on a Turing machine,and so have an enumeration prodcedure for the language.so the lanuage is recursively enumerable.so the grammar generates strings by a well-defined algorithmic process,so the derivations can be done on a Turing machine.for the second part we show the converse,and describe how we can produce an unrestrcited grammar by a Turing machine as express by Turing_Machine_To_Unrestricted_Grammar algorithm and this theorem Theorem:for every recursively enumerable language L,there exits an unrestricted grammar G,such that L=L(G).to prove it we have that Turing_Machine_To_Unrestricted_Grammar algorithm shows that x|-y,then e(x)=>e(y),where e(x) denotes the encoding of a string based on Turing_Machine_To_Unrestricted_Grammar algorithm,by an induction on the number of steps,we can show that e(q0w)=*>e(y) iff q0w|-*y.then we must show that we can generate every possible starting configuration and and that w is propertly reconstrcuted iff M enters a final configuration and proof is complete.so these two theorems show that unrestricted grammars generate recursively enumerable languages.,>>>>a variation an grammars in which starting point for any derivation can be a finite set of strings,rather than single variable is equivalent to unrestricted grammars,>>>>for every unrestricted grammar there exists an equivalent unrestricted grammar,all of whose productions have the form: u->v with u,v elements of (V union T)+ and |u|<=|v|,or A->Lambda with A element of V.also if we add the further consitions |u|<=2 and |v|<=2 our conclusion still holds.,>>>>this definition of unrestricted grammars so that its production must be of form x->y,where x is in (V union T)*V(V union T)*,and y is in (V union T)*,so the difference is that here the left side must have at least one variable is equivalent with presented definition of unrestricted grammar. };
        //public enum Context Sensitive Grammar Properties { between the restricted,context-free grammars and the general,unrestricted grammars,a great variety of "somewhat restricted" grammars can be defined,not all cases yield interesting results;among the ones that do,the context-sensitive grammars are more important,they generate languagew associted with linear bounded automata and defined as follows: a grammar G =(V,T,S,P) is said to be context-sensitive if all productions are of the form: x -> y,where x,y are the elements (V union T)+ and |x|<=|y|.,>>>>these grammars are called context-sensitive becuase it can be shown that all such grammars can be rewritten in a normal form in which all productions are of the form xAy->xvy.this is equivalent to saying that the production A->v can be applied only in the situation where A occurs in a context of the string x on the left and the string y on the right,>>>>this type of grammar is noncontracting in the sense that the length of successive sentential forms can never decrease,also in this definition x->Lambda is not allowed so a context-sensitive grammar can never generate a language containing the empty string,and when we derive sentential forms from it the varibles in the grammar are used as messengers so that a variables is craeted on the left then tarvels right,when it reaches a specific symbol then e.g. craetes another terminals and sends another variable as the messenger back and so on,and its process is very similar to programming a Turig machine to accept language L,also we have that its not an easy matter to find a context-sensitive grammar even for relatively simple example.often the solution is most easily obtained by starting with a Turing machine program lba,then finding an equivalent grammar for it,also we have that when a grammar is context-sensitive then it can be viewed as a linear bounded automata as expressed by these two theorems,Theorem:for every context-sensitive language L not including Lambda,there exists some linear bounded automaton M such that L=L(M),to prove it we have that if L is a context-sensitive grammar then we have a context-sensitive grammar for L-{Lambda},then we should show that derivations in this grammar can be simulated by a linear bounded automaton,the linear bounded automaton will have two tracks one containinf the input string w ,and other containing the sentential forms derived using G,a key point of this agrument is that no possible sentential form can have length greater than |w|.another point is that a linear bounded automaton is nondeterministic by definition,and its necessary in the argument,because we can tell that the correct production can always be guessed and no unproductive alternatives have to be pursed.so,converting a Turing machine to an unrestricted grammar can be done with only space that originally occupied by w;that is,it can be done by a linear bounded automaton.and we have this theorem for the coverse,Theorem:if a language L is accepted by some linear bounded automaton M, then there exists a context-sensitive grammar that generates L.to prove it we have that Turing_Machine_To_Unrestricted_Grammar algorithm shows that x|-y,then e(x)=>e(y),where e(x) denotes the encoding of a string based on Turing_Machine_To_Unrestricted_Grammar algorithm,by an induction on the number of steps,we can show that e(q0w)=*>e(y) iff q0w|-*y.then we must show that we can generate every possible starting configuration and and that w is propertly reconstrcuted iff M enters a final configuration.now we have that all productions generated here are noncontracting except blank->Lambda.but we can omitt this productions,since is necessary only when the Turing machine moves outside the bound of the original input,which isnt the case here.so the constrcuted grammar by the algorithm without this unnecesary production is noncontardicting and proof is complete.so by this theorem we have that every context-sensitive language is accepted by a Turing mhcine and is therefore recursively enumerabel so we then present this thorems:Theorem:every context-sensitive language L is recursive,to prove it we have that we consider the context-sensitive language L and its associted context-sensitive grammar G and look at a derivation of w:S=>x1=>x2=>...=>xn=>w.we can assume without loss of generality that all sentential forms in a single derivation are different;that is,xi!=xj,for all i!=j.we know that |xj|<=|x(j+1)| since G is noncontarcting.also we have that there exist some m,depending only on G and w,such that |xj|<|x(j+m)| for all j,with m=m(|w|) a bounded function of |V union T| and |w|.this follows becuase |v union T| is finite then there are only a finite number of strings of the given length.so the length of the derivation of w in L is at most |w|m(|w|).we can now present a membership algorithm for L as follows,we check all rerivationsa with length up tp |w|m(|w|),since the set of productions f G is fnnite,number of these is finite,if any of these give w,then w is in L,other wise its not,and also we have this theorem,Theorem:there exists a recursive language that is not context-sensitive.to prove it we hvae that we consider the set of all context-sensitive grammars on T={a,b} we use a convention in which each grammar has the following varibel set V={V0,V1,V3,...},also we know that every context-sensitive grammar is completely specified by it`s producdions we can consider that they are written as a single string x1->y1;x2->y2;...;xm->ym.to this string we now apply the homomorphism h(a)=010,h(b)=01^(2)0,h(->)=01^(3)0;h(;)=01^(4)0;h(Vi)=01^(i+5)0.thus any context-senstive grammar ca be represented uniquely by a string of form L((011*0)*).also,the represenaton is invertible that is,for any such string,there is at most one context-sensitive grammar for it.now introduce a proper ordering on {0,1}+ so we can write strings in the order w1,w2,etc.now we define following language L={wi defines a context-sensitive grammar Gi and wi isnt in L(Gi)} that is,a given string wi doesnt define a context-sensitive grammar;if it does,call the grammar Gi ,L is well-defined and is in fact recursive,to prove it we constrcut a membership algoeirhm for it,so that,given wi,we check if defines a context-sensitive grammar Gi,if it is,then L(Gi) is recursive,and we can use the memebership algorithm of last thorem to find out that if wi is in L(Gi).if it isnt,then wi isnt in L and w belongs to L.but L isnt context-sensitive,if it were,there is some wj such that L=L(Gj),now we look that if wj is in L(Gi) if we assume wj is in L(Gj),then by definition but L=L(Gi) so we have a contradiction.conversly, if we assume wj isnt in L(Gi),then by definition wj is in L so again its a contradiction.so we must conclude that L isnt context-sensitive,also we know that every context-free language without Lambda can be generated by a special case of context-sensitive grammars e.g. in Chomsky or Greibach normal forms that both of which satisfy coditions of context-sensitive grammars.so by including the empty string in the definition of a context-sensitive language(but not in the grammar) and also by finding languages that are context-sensitvie but not context-free,we can claim that the family of context-free languages is subset of the family of context-sensitive languages ,also by these two theorems we can conclude that linear bounded automaton are less powerful than Turing machines since they accept ony a proper subset of recursive languages,also we can see from that theorem that linear bounded automata are more powerful than pushdown automaton and context-free languages are proper subset of context-sensitive langauges };
        //public enum Context Sensitive Languges Properties { a language L is said to be context-sensitive if there exists a context-sensitive grammar G,such that L=L(G) or L=L(G) union {Lambda},>>>>the family of context-sensitive languages are closed under union and reserval};
        //public enum Language Families Chomsky Hierarchy Properties { one way of exhibiting the relationship between language families is by the Chomsky hierarchy.Noam Chomsky,a founder of formal language theory a classification consisting of four language types,type 0 to type 3.but the numeric types different names for lanugage families,Type 0 are the recurively enumerable languages,Type 1 are context-sensitive lanuages,Type 2 are context-free languages,and Type 3 are regular languages,and we have that each language family of type iis a proper subset of the family of type i-1.the original Chomsky hierarchy conisists of L(REG)<L(CF)<L(CS)<L(RE) so that regular languages are proper subset of deterministic context free languages its proper subset of context free languages its proper subset of context sensitive languages its proper subset of recursive languages its proper subset of recursive enumerable languages also we can include determisistic context-free languages(L(DCF)) and recursive languages(L(REC)) and we haver this hierarchy :L(REG)<L(DCF)<L(CF)<L(CS)<L(REC)<L(RE) also we can add other lanuages to this hierarchy but their relationship dont always have this neatly nested structure and in some instanes are not completely understood e.g. we know that the context-free language L={w:na(w)=nb(w)} is deterministic but not linear,and the language L={(a^n)(b^n)} union { (a^n)(b^(2n)) } is linear,but not deterministic the raletionship between regular,linear,deterministic context-free and nondeterministic context-free is as follows:regular languages are proper subset of deterministic context-free languages, linear languages and context-free languages,linear languages and deterministic context-free languages are proper subset of context-free languages but they have a common area with each other which the common area includes regular languages and three of them are proper subset of context free language,>>>>at this time,it is not known whether the family of languages accepted by deterministic linear bounded automata is a proper subset of the context-free languages,and we dont know what role nondetrminism play in these languages.};
    }
}
