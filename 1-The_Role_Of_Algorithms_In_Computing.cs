using System;

namespace Data_Structure_And_Algorithms
{
    public class The_Role_Of_Algorithms_In_Computing
    {
        //public enum Algorithm Properties { informally an algorithm is any welldefined computational procedure that akes some value or set of values as input and produces some value or set of values as outputsoits a sequence of computational steps transfoming input into output,>>>>an algorithm is a finite set of instructions that if followed accomplished a particular task in addition all algorithms must satisfy the following criteria 1) input zero or more quantities are externally supplied 2) output at least one quantity is produced 3) definiteness each instruction is clear and unambiguous 4) finiteness if we trace out the instructions of an algorithm then for all cases the algorithm terminates after a finite number of teps 5) effectivness every instruction must basic enough to be carried out in principle by a person using only pencil and paper its not enough thateach operation be definite as in 3 it also must be feasible in computational theory one distinguishes betweenan algorithm and a program the latter of which does not have to satisfy the fourth condition eg operating system is program cause it doesnt ternminate unitl systtem crashes,>>>>an algorithm iscorrect if for every input instance it halts with the correct output we say that a correct algorithm solves the given computational problem ,an incorrect algorithm might not halt at all on some input instances or it might halt with an answer other than the desired onecontrary to expectation incorrect algorithms cn sometimes be useful if their error rate can be controlled,>>>>an algorithm can be specified in english as a computer program or even as a hardware design,>>>>we can describe algorithms in many ways we can use a natural language like english but the resulting instarcutions shoud be defiite graphic representations called flowcharts are another possibility but they work well only if the algorithm is samll and simple,>>>>there are many computational problems for which we should find an algorithm but there are some underlying techniques that apply to these prblems and problem areas so that we can use them or develope similar all of the computational problems have to common charatcreistics 1) there are many candidate solutions most of which are not what we want finding one that we do want can present quaite a challange 2) there are practical applciationsfor them,>>>>measure of efficiency of an algorithm is speed ie how long an algorithm takes to produce its result so bu using NPP problems when we want to find to produce an efficient problem then if we can show that problem is NP then we can spend out time developing an efficient algorithm that gives a good but not the bestpossible solution,>>>>even for very fast computers slow algorithm may slow down greately the computer operation so algorithms like computer hardware are a technology total system performance depends on choosing efficient algorithms as much as on choosing fast hardwarejust as rapid advances are being made in other computer technologies they are being made in algorithms as wellwe might woder whther algorithms are truly important on contemparary computers in light of other advanced techmologies such as 1 hardware with high clock rates pipelining and superscalar architectures 2 easy to use intuitive user interfaces GUIs 3 object oriented systems 4 local area and wide area networking answeer is yesalthough some applications do not explicitely require algorithmic content at application level eg some simple webbased appliactions most also requier a degree of algorithmic content eg a web application determining how to travel from one locaion to other it may include hardware a GUI WAN networking and also object orientation however it would also requie algorithms for certain operations such as finding routes redering maps and interpolating addresses moreover even an application that does not require algorithmic contentat application level relies heavily upon algrithms eg hardware design GUI design network routing compilers design algorithms are core of most technologies used in contemporary computers having a solid base of algorithmic knowledge and technique is one characteristic that seperates the truly skilled programmrs from the novices with modern computing technologies you can accomplish some taks without knowing much about algorithms but with a good background in algorithms you can do much much more};
        //public enum Computational Problem Properties { a satement of problem specifying in general terms the desired input output relationship,>>>>in general instance of a problem conisits of the input satisfying whateveer constarint are imposed in problem statement needed to compute a solution to the problem,>>>>some kinds of practical applications for problem are genes parinf for DNA rout finding finding pages on interet cryptography resource allocation for some ways };
        //public enum Data Structure Properties { a data structure is a way to store and organaize data in order to facilitate access and modifications no single data structure works well for all purposes and so its important to know strengths and limitations of several of them };
        //public enum Large Scaled Computer Programs Properties { good programmers regard large scaled computer programs as sysytems that contain many complex interacting parts as systems these programs undergo a developement process called the sysytem life cycle this cycle consists of (1)requirements:"set of specifications defining porpose of projectincluding information programmers are given(input) and the results that we must produce(output) and we must endetail them later" (2)analysis:"in this phase we braek the problem down into managable peices there are two approaches to analysis:bottom-up and top-down in bottom up we have empahsis on coding first fine points its unstructured resulting lossely connected error-riden segmentssince programmer doent have a master plan for project and the specific purpose to which building will be put is not considered in this approach in top-down aproach we devlope a high-level plan to divide the program to managable parts then we refine plan to contain lower level details and so geerting diagarams and dveloping and comparing alternate solutions" (3)design:" in this phase we coniser data objects that the program needs and the operations proformed on them first leads to creation of abstarct data ypes wheres swecond requires the specification o falgorirhms and s conisration of algorithm design strategies since these are langauage-indpendent we postpone impementations decisions so we can implemnt it in several languages and also we can choose the best impementation for it " (4)refinement and coding " in this phase we choose representations for our data objects and write algorithm for each operation on them their order is important since data objects`srepresentaion dteremines efifcency of algorithms related to it and now we can notice other alternates and if our original design is good it can absorb changes easily " and (5)verification " thsi phase conisits of developing corectness proofs for program tetsing the program with variety of input data and removing errors for correctness proofs they means that programs can be proven correct using the same techniques that abound in mathematics unfortunately these profs are very time-comsuming and difficult to develope frlarge projects but we can use them for algorithm ,testing means that using working code and sets of test data this data should include all possible scenarios and verifiies that every piece of code runs correctlyinitial sysytem tests focus on verifying taht a program runs correctly also we must have theorerical estimates of runingitmes also we may want to gather perfomance estimates for portions of our code error removal measn that removing errors after correctness proofs and testing which depends on teh design andcoding decisons made earlier e.g. a large undocumented code is difficult for error correction since corecting each error possibly generetes several new errors but a well documented program divided into automanous units that interact throgh parameters is far easier especially if each unit is tested seperately and then integrated into the system" phases also data abstratcion encapsulation algorithm specification and performance analysis and measurement provides tools and techniques necessary to design and implement large scale computer sysytems };
    }
}
