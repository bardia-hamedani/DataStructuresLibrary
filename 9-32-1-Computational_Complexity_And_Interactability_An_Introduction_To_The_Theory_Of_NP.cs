using System;

namespace Data_Structure_And_Algorithms
{
    public class Computational_Complexity_And_Interactability_An_Introduction_To_The_Theory_Of_NP
    {
        //public enum Polynomial Time Algorithm Properties { is one whose worst case time complexity is bounded above a polynomial functoin of its input size that is if n is the input size there exists a polynomial p(n) such that W(n) = O(p(n)) };
        //public enum Intractable Problem Properties { a problem which its impossible to solve it with a polynomial time algorithm,>>>>intractability is a property of a problem its not a property of any one algorithm for that problem for a problem to be intracable there must be no polynomial time algorithm that solves it obtaining a nonpolynomial time algorithm for a problem does not make it intracable e.g. chained matrix multiplication problem in nonpolynomial time for brute-force and divide and conquer but polynoimial for dynamic programming so this problem is nt intracable,>>>>we know that polynomail-time algorithms are usually much better than algorithms not plyonimal -timee.g.if 1 nanosecond takes to process basic instruction an algorithm of complexity n^3will process an instance size of 100 in 1 millisecond whereas an algorithm with time complexity of 2^n will take billins of years we can create extreme examples in whcih a nonpolynomial -time algorithm is better tahn a polynomial time algorithm furthermore many algorithms whose worst-case time complexities are not polynomials have efficient runign times for many actual instances this is case for many abcktarcking and branch-and-bound algorithms so our definition of intracable is only a goodindication of real intracibility in any particular case a probelm for which we have found a polynomial algorithm could be more dificcult to handle for particular input sizes tahn one we cant find such an algorithm there are three categories of problems as far as intarcibility is concerned:(1)probelms for which polynomial-time algoithms have been found (2)probelms taht have been proven to eb intracable(3)problems taht have not been proven to be intarcable but for which polynomial-time algorithms have never been found it is surprising taht most peoblems in computer science seem to fall into either first or third category };
        //public enum Algorithm Input Size Priperties { so far it has ususally sufficed to call n input size in our algorithm since n has been a reasonable measure of amount fo data  e.g. in sorting algorithm n be number of keys but in in prime algorithm in that parameter n is the input to algorithm its not size of input that is each value of n constitutes an instance of problem unlike of sorting algorithm taht n is number of keys and the instance is the n keys for a given algorithm the input size is defined as the number of characters it takes to write the input to count the characters it takes to write the input we need to know how the input is encoded if we use binary then the characters used for encoding are binary igits(bits)and number of charcters it takes to encode a positive integer x is [lg x]+1 so we can its lgx if we want to determine the input size for an algorithm of sorting n integers so w have that input size is count of the number of  bits it takes to encode tehm if the largest integer is L and we encode each integer in number of bits neededto encodethe largest then it takes about lg L bits to encode each of them so input size is n*lgL if we use base 10 instead result doesnt change if we restrict ourselves to reasonable encoding schemes then the particular encoding scheme used does not affect the determination of whether an algorithm is polynomial time or non polynomial time there does not seem to be a satisfactory formal definition of "reasonable" but for most algorithms we usullay agrre on what is resoablee.g. eny encoding other tahn 1 is reanoable };
        //public enum Algorithm Worst Case Time Complexity Properties { for a given algorithm W(s) is defined as the maximum number of steps done by the algorithm for an input size of s ,>>>>we used s instead of n for input size since (1)the parameter n to our algorithms is not always a measure of input size (2)wehn n is a measure of the input size its not ordinary a precise measure of it,>>>>according to that definition we must count al the steps done by algotihm e.g. in exchange sort number of steps done to increment loops and do branching is bounded by a costant c times n^2 if integers are sfficently large they cnt be compared or assiged in one step y computer so we should not consider one key compariosn or assignemnt as one stepwe consider one step one bit comparison or one bit asignmentso if L is lagest integr it takes at most lg L steps to compare one integer or to assign one integr we know that this algotithm has n(n-1)/2 comparsions of keys and 3n(n1)/2 asigments to sort n positive integsr so maximum number of steps done by it is W(s)=W(nlgL) so thsi algortihm remains polynomial time when we are precise in the input size we can obtain similar results for all algorithms which we`ve shown to be polynomial-time using imprecise inputsizes also we can show the algoerthms which we`ve shown to be nonpolynomail-time remian nonpolynmial-time when we are precise about input size so if use n as input size and we obtain correct result of problem to be polynomial-time then we continue to use it now assume in prime checking probelm input size is number of characters it takes to encode n so if we use base 10 to encode and we set s=log(n) then s is approximately the size of input in worst-case there are floor[n^(1/2)] -1 passes through the loop infunction prime becasue n=10^s worst-cae number of passes through loop is 10^(s/2) sinc ttal number of steps is at least equal to number of passes through loop time complexity is nonpolynomail if we use binary encoding we have 2^(r/2) passes throgh the loop so time is still polynomial resluts remain unchanged as longas we use a "reasonable" encoding scheme e.g. unary notation isnt reaboable since it will take n characters to encode number n by using it prime checking problem is polynomail-time };
        //public enum Algorithm Step Properties { can be considered the equivalent of one machine comparision or assignment or to keep the analysis machine independent one bit comparision or assignment so each step constitutes one execution of the basic operation };
        //public enum Algorithm Input Magnitde Properties { in algorithms such as the prime-checking algorithm we call n a magnitude in thre input so when size of input isnt input size but number of characters is input size,>>>> also its the case in nth Fibonacci term which is Theta(n) n is magnitude in input and lg n measures size of input time complexity is linear in terms of magnitudes but exponential in terms of size time complexity for computing the bionomail coefficient is in Theat(n^2) since n is magnitude in input and lg n measures size of input time complexity is quadratic in terms of magnitudes but exponential in terms of size in dynamic-programming algorithm for 0-1 knapsack probelm run-time is Theat(nW) n si measure of size since its number of items in input but W is a magnitude since its tehmaximum capacity of the knapsack lgW measures size of W algorithm time complexity is polynomail in terms of magniutes and size but its expoential in terms of size alone };
        //public enum Pseudopolynomial Algorithm Properties{ an algorithm whose worse time complexity is bounded above by a polynomial function of its size size and magnitude,>>>>such an algorithm can often be quite useful because its inefficient only when confronted with instances containing extremely large numbers which might not petain to the application of ineterst e.g. in 0-1 knapsack probelm we dont like large Ws };
        //public enum Categories of Problems As Far As Intractability Is Concerned { problems for which polynomial time algorithms have been found,>>>>problems that have been proven to be intracable,>>>>problems that have not been proven to be intractable but for which polynomial time algorithms have never been found };
        //public enum Problems For Which Polynomial Time Algorithms Have Been Found Category Properties {any problem for which we havefound a polynomial time algorithm falls in this firt category,>>>>some of problems in this category are theta(nlgn) for sorting theta(lgn) for searching sorted array theta(n^2.38) for matrix multiplication theta(n^3) for chained matrix multiplication and so on since n i a measure of amount of  data in inputs to thee algorithms they are all polynomial,>>>>there are probelms taht there is polyminal time and also nonploymialtime e.f. matrix chain multiplication brute force algorithm optimal search tree and minimum spanning tree };
        //public enum Problems That Have Been Found To Be Intractable Category Properties { there are two types of problems in this category the first type is problems that require a nonpolynomial amount of output e.g. in probelms like determing all Hamiltonian Circuits if there is an edge from every vertex to other vertex there are (n-1)! circuits to the problem algorithm would have output all of these circuits meaning our request isnt reasonable so its important to recognize this type of intractability and its usually straightforward to recognize that a nonpolynomial amount of output is being requested so we are aksing more information than we could possibly use so problem is not defined realisticlly,>>>>the second type of intractability occurs when our requests are reasonable that is when we are not asking for a nonpolynomial amountof output and we can prove that the problem cant be solved in polynomial time and we have found relatively few such problems like undecidable problems they are called this since it can be proven taht algorithms that solve them cant exist most well-known of them is Halting problem in that we take as input any algorithm any input to that algorithm and decide whether or not the algorithm will halt on them also there were secidable poblems taht are itracable however these kinds of probelms were artificially constrcuted to ahev certain properites also there are some natural decidable decisoin proeblems that are intracable e.g. Presburger Arithmetic problem the output for a decision probelm is a simple "yes" or "no" so the amount of output requested is ceratinly reasonable all problems taht to this date haev been proven intarcable have a;lso proven not to be in set NP howeevr most probelms taht appear to be intracable are in set NP };
        //public enum Problems That Have Not Been Proven To Be Intractable But For Which Polynomial Time Algorithms Have Never Been Found Category Properties { this category includes any problem for which a polynomial algorithm has never been found but yet no one has ever proven that such an algorithm is not possible ,>>>>if we state the problems so as to require one solution then problems in this category are 0-1 knapsack problem the traveling salesman problem the sum of subsets problem the m-coloring problem for m>=3 the hamiltonian circuits problem and the problem of abductive inference in a bayesian network,>>>>there are backtracking and branch and bound algorithms and other algorithms that solve them in polynomial time but its only for intances from restricted subset and not all subsetsto show this we need only find some infinite sequence of intances for which no polynomial in n bounds the number of times teh basic opetaion is done};
        //public enum Desicion_Problem_Properties { the output of a decisoin probelm is a simple "yes" or "no" each optimization problem has a corresponding decision problem ,>>>>if we could find a polynomail-time algorithm for the optimization problem we would have a polynomail-time algorithm for the corresponding decision problemthis is becsue a solution to an optimization problem produces a solution to the corresponding decision problem e.g. if we learned that total weight of an optiaml tour for a particular instance of traveling salesman probelm was 120 the answer to corresponding deciiosn problem would be "yes" for d>=120 and "no" otherwise,>>>>because a polynomail time algorithm for an optimization problem automatically produces a polynomail time algorithm for corresponding decioin proeblm in categorizing algorithm to P and NP sets we use only decision problems then we have that for many decisoin probelms it`s been shown that a polynomail-time algorithm for the deciion probelm would yeild a polynomial time algorthim for corresponding optimization problem};
        //public enum The Traveling Salesperson Decision Problem Properties { is to determine for a given positive number d whether there is a tour having total weight no greater than d this problem has the same parameters as the traveling salesperson optimization problem plus the additional parameter d,>>>>its NP complete from proof from reducing traveling salesperson undirected decision problem so that transform an instance (V,E) of traveling salesperson (undirected)decision problem to an intance traveling salesperson decision problem  with same vertices and has edges (u,v) and (v,u) both in E`whenever (u,v) is in E and they have smae weight  so (V,E) has an undirected tour with total weight no greater than d iff (V,E`)has a directed tour with total weight no greater than d };
        //public enum The Traveling Salesperson Undirected Decision Problem Properties { it is given a weighted undirected graph its to determine for a given positive number d whether there is a tour having total weight no greater than d ,>>>>polynomial-time verification algorithm given for traveling salesperson problem also works for this so theproblem is NP ,>>>>to prove that its NP-complete we need to show that some NP-complete problem reduces to it weshow that Hamiltonian circuits deision problem~(reduces)traveling salesperson (undirected)decision problem transform an instance (V,E)of the Hamiltonian circuits deision problem to the instance (V,E) of the traveling salesperson (undirected)decision problem having the same set of vertices V hasan edge between every pair of vertices and has folowing weights:Weight of (u,v) equal to {1 if (u,v)in E 2 if (u,v) in E}  };
        //public enum The 0 1 Knapsack Decision Problem Properties { is to determine for a given profit P whether its possible to load the knapsack so as to keep the total weight no greater than W while making the total profit at least equal to P this problem has the same parameters as the 0 1 knapsack optimization problem plus the additional parameter P };
        //public enum The Graph Coloring Decision Problem Properties { is to determine for an integer m whether there is a coloring that uses at most m colors and that colors no two adjacent vertices the same color this problem has the same parameters as the graph coloring optimization problem plus the additional parameter m };
        //public enum The Hamiltonian Circuirts Decision Problem Properties { is to determine whether a connected undirected graph ha at least one tour,>>>>its NP compete proof from reducing from CNF satisfiability };
        //public enum The Clique Optimization Problem Properties { a clique in an undirected graph G =(V,E) is a subset W of V such that each vertex in W is adjacent to all the other vertices in W a maximal clique is a clique of maximal sizethe clique optimization problem is to determine the size of a maximal clique };
        //public enum The Clique Decision Problem Properties { is to determine for a positive integer k whether there is a clique containing at least k vertices this problem has the same parameters as the clique optimization problem plus the additional parameter k,>>>>its NP complete proof from reducing CNF satisfiability to it,>>>>this problem is NP-complete so show that we must have :CNF-Satisfiability~(reduces)Clique Decision Problem so let B=C1^C2^...^Ck be a logical expression in CNF where each Ci is a clause of B and x1,...,xn be variables in Btransform B to a graph G=(V,E) as follows:V={(y,i) such that y is a literal in cluase Ci} E={((y,i),(z,j) such that i!=j and (not z)!=y} this transformation is polynomial time so we need to show taht if B is CNF-Satisfiable iff G has a clique of size at least k so we have (1)to show if B is CNF-Satisfiable G has a clique of size at least k  so if B is CNF-Satisfiable then thereis some xis assigmanet so taht each clause si true  meaning with these assigmanets there is at least one literal in each Ci that is true pick such literal from each Ci then let V`={(y,i) such taht y is teh true literala picked from Ci} clearly V` forms a clique of size k(2)we show reverse of consition  since we dont have (y,i) and (z,i)all indices in clique vertices are diferent so since clique has k differnt indices it has a most k vertices so clique of size at least k has k vertices so S={y such that (y,i) in V`} S contains k literals S contains literla from eac k clauses and sinc S cant contain both a literal y and not y so if we set xi={true if xiinS fasle if not x in S} and assign true to not in S varaibles all clause in B are tre so B is CNF-Satisfiable  };
        //public enum Set P Properties { P is the set of all decision problems that can be solved by polynomial time algorithms,>>>>all decision problems for which we have found polynomial time algorithms are in P e.g. the problem of determinig whether a key is present in an array the probelm of determining whether a key is present in a sorted array the decision probelms for optmization probelms for whixch we have found polynomail time algorithm,>>>>there are probelms like Traveling Saleperson that even through no one has ever created a polynomial-time algorithm solving this problem no one has ever proven that it cant be solved with a polynomail time algorithm so it could possibly be in P to know that a decision problem is not in P we have to prove it is not possible to develope a polynomial time algorithm for it  };
        //public enum Decision_Algorithm_Polynomial_Time_Verifiability_Properties { if we have an answer to a decision problem such taht its "yes" then we have the answer and we write the algorithm following to verify whether answer is accurate if it is algorithm returns true otherwise returns false returnning false means only that this answer doesnt match our problem it does not mean such a true answer does not exist becasue there might be a different answer that match the problem this means that given an answer we can verify in polynomial time whether this answer proves taht the answer to our decision probelm is "yes" and not verifying anser is "no" it is this property of polynomail time verifiability possessed by the problems in set NP,>>>>when we use them it doesn`t mean that these probelms can be solved in polynomail tiemwehn we verify that answer matches our problem we are not including time it took to find taht answer we are oly saying the verification part takes polynomail time,>>>>function verify does verification stage for decisoin problems };
        //public enum Nondeterministic Algorithm Properties { we can think of such an algorithm as being composed of two seprated stages (1) guessing(nondeterministic)stage: given an instance of a problem this stage simply produces some string S the string can be thought of as a guess at a solution to the instance however it could just be a string of nonsense this stage is called nondeterministic because unique step by step instructions are not specified a "nodeterministic satge"is a defitional device for obtaining the notion of polynomail-tiem verifiabilityits not a realistic method for solving a decision probelm for it the second part (2) verification (deterministic) stage: the instance and the string S are the input to this stage this stage then proceeds in an ordinary deterministic manner either(1)eventually halting with an output of true which means that it has been verified that the answer for this instance is yes (2) halting with an output of false or (3) not halting at all in these latter two cases it has not been verified that answer for this instance is yes these two cases are indinguishable,>>>>even through we never actually use a nondeterminstic algorithm to solvea probelm a nondeterministic algorithm solves a decision problem if (1) for any instance for which the answer is "yes" there is some string S for which the verification stage returns "true" (2) for any instance for which the answer is "no" there is no string for which the verification stage returns "true",>>>>wehn we want to use a nondeterministic algorithm to solve a problem  we must have athat if the answer for a particlar instance is "yes"function verity returns "true"whenan accurate answer is in input so criterion 1 of a nondeterministic algorithm is satisfied  on the other hand function verify only returns "true" when an accurate answer is inputso if answer for an instance is "no" fucntion verify does not return "true" for any value of S meaning that criterion 2 is satisfied so a nondterministic algorithm taht simply generates strings in guessing state and calls function verify in verification satge "solves" taht problem };
        //public enum Polynomial Time Nondeterministic Algorithm Properties { is a nondeterministic algorithm whose verification stage is a polynomial time algorithm };
        //public enum Set NP Properties { is the set of all decision problems that can be solved by polynomial time nondeterministic algorithms,>>>>NP stands for nondeterministic polynomial,>>>>for a decision problem to be in NP there must be an algorithm that does the verification in polynomial time but this does not mean that we necessarily have a polynomial time algorithm that solves that problem e.g. in traveling salesperson if ansewer for a particular problem is "yes" we might try all tours in detrministic satge before trying one for which verify returns"true" if all vertices were conncted  we have (n-1)! tours so if we check them all asnwer will not be found in polynomaiol time o if answer of an intance is "no"slving probelm requires all anwers to be chekdwe can use branch-and -bound instead or other algorithms which is better than genertaing al tours but purpose of non-determinsitic algorithms and NP is to classify algorithm so we use thos algortihms ,>>>>what decision probelms are in NP?there are thousands of other problems taht no one has been able to solve with polynomial-time algorithms but are in NP since polynomail-time nondeterministic algorithms have been developed for them and also every problem in P is also in NP since any probelm in P can be solved by a polynoamil-time algorithm so we can generate any nonsense in nondeterminisitic stage and run taht polynomial-time algorithm in determinisitc stage ,>>>>what decision probelm are not in NP?the only decision problems that have been proven not to be in NP are the same ones that have been proven to be intractable that is the halting problem presburger arithmetic etc we have found relatively few such problems,>>>>NP contains P as a proper subset but no one has ever proven that there is a problem in NP that isnt in P therefore NP - P may be empty ,>>>>the question of whether P equals NP is one most intriguing and inportant questions in computer science its important because most decision probelms ar in NP so if P=NP we have polynomial time algorithms for them to show P!=NP we should find a problem in NP that is not in P but to show P=NP we ahve to find a polynomial-time algorithm for each problem in NP but we can simply latter one so that finding only one polynoail-time alogrithm for only a large class of problems in spite of this great simplification many researchers doupt that P = NP };
        //public enum The CNF Satisfiability Decision Problem Properties {we know that a logical expresion in conjuctive normal form(CNF) is a sequence of clauses seperated by thelogical and operator (^) ,>>>>this problem is to determine for a given logical expression in CNF conjunctive normal form or and whether there is some truth assignment some set of of asignmne of truth and false to the variables that makes the expression true,>>>>its easy to write a polynomail-time alfgorithm taking as input a logical expression in CNF and a set of truth assingments to variables and verifies whether teh expression is true for taht assignment so the probelm is in NP,>>>>CNF satisfiability is NP complete and its proof exploits common properties of problems in NP to show that any problem in this set must reduce to CNF satisfiability };
        //public enum Transformation Algorithm Properties { suppose we want to save decision problem A and we have an algorithm that solves decision problem B suppose further that we can write an algorithm that creates an instance y of problem B from every instance x of problem A such that an algorithm for algorithm B answers yes for y if and only if the answer to problem A is yes for x such an algorithm is called a transformatio algorithm and is actually a function that maps every instance of problem A to an instance of problem B we denote it as follows y=tran(x) the transformation algrithm combined with an algorithm for problem B yeilds an algorithm for problem A,>>>>for example we have two probelm (1)given n logical varaibles does at least one of them is "true"?second(2)given n integers is the largest positive? our transformation is k1,k2,...,kn=tran(x1,..,xn) whre ki is 1/0 if xi is true/fasle an algorithm for our second problem is "yes" iff at least one ki is 1 so iff at least one xi is true so our transformation is successful we can solve first probelm using an algorithm for second problem };
        //public enum Polynomial Time Many One Reduction Properties { if there exists a polynomial time transformation algorithm from decision problem A to decision problem B problem A is polynomial time many one reducible to problem B(usually we just say taht problem A reduces to problem B) A~(reduces)B we say "amny-one" since a trasformation algorithm is a function taht may map many instances of probelm A to one instacne of problem B so its a many-one function,>>>>if the transformation algorithm is polynomial time and we have a polynomial time algorithm for problem B intuitively it seems that the algorithm for problem A that results from combining the transformation algorithm and the algorithm for problem B must be a polynomial time algorithm the following theorem poves that this is so Theorem:if decision problem B is in P and A ~(reduces)B then decisoin probelm A is in P };
        //public enum Set NP Complete Properties { a problem B is called NP complete if both of the following are true (1) B is in NP (2) for every other problem A in NP A polynomial time many one reduces to B(A~B) so if we could show taht any NPcomplete probelm is in P we could conclude taht P=NP also we have this theorem (Cook`s Theorem)CNF-Satisfiability is NP_complete this theorem does not cosisits of reducingeevry probelm individully CNF_Satisfiability this proof exploits common properties of probelms in NP to show any problem in this set msut reduce to CNF_Satisfiability so many other problems were proven to be N-Compete these proofs rely on the follwing theorem Theorem: a problem is NP complete if both the following are true (1) C is in NP (2) for some other NP complete problem B B polynomial time many one reduces to C so we can show hat a problem is NP_complete by showing it is in NP and that CNF-Satisfiebility reduces to it also we can also used another NP-complete proved problems instaed of CNF-Satisfiability,>>>>we may pay attention that probelm like Traveling Slaeperson and 0-1 Knapsack that both are in NP dont have same diffculty so that perhaps the 0-1 knapsack proelm is inherently easier tahn Traveling Salesperson problem but these two probelms and thousands of other probelms are all equivalent are all equivalent in the sense that if any one is in P they all must be in P such probelms are called NP-coplete,>>>>a decision problem that is in NP and is not NP complete is the trivial poblem that answers yes for all instances or answers no for all instances this problem is not NP complete because its not possible to transform a nontivial decision problem to it,>>>>since NP-complete is a subset of NP then Presburger Arithmetic the Halting problem andany decision problem no in NP are not NP-complete a decision problem that is in NP and is not NP-complete is the trivial decision problem that answers "yes" for all instances or "no" this problem isnt NP-complete since its not possible to transform a nontrivial decision problem to it so if P=NP we have a set NP and P and as its subset NP-complete and if P != NP then we have a set P with two disjoint subset NP-complete and P so P union NP-complete=Empty this is becuase if some problem in P were NP-complete so we would solve any problemin NP in polynomial time also no one has been able to prove taht there is a probelm in NP taht is neither in P nor NP-complete however it has been proved taht if P!=NP such a probelm msut exists so this result is formalized by this theorem:Theorem if P!=NP the set NP -(P union NP-complete) together is not empty };
        //public enum The Graph Isomorphism Problem Properties { two graphs G=(V,E) and G`=(V`,E`) are called isomorphic if there is a one to one function from V to V` such that for every v1 and v2 in V the edge (u,v) is in E if and only if the edge (f(u), f(v)) is in E` the graph isomorphism probelm is as follows given two graphs G=(V,E) and G`=(V`,B`) are they isomorphic? its in NP a straightforward algorithm for this problem is to check all n factorial noe to one onto mappings where n is the number of vertices this algorithm has worse than exponential time complexity no one has ever found a polynomial time algorithm for this problem yet no one has ever proven its NP complete therefore we do not know whether its in P and we do not know whether its NP complete so its in NP-(P union NP-complete),>>>>no one has been able to show the complementary problem to the graph isomorphism problem is in NP };
        //public enum Complementary Problem Properties {a complementary probelm to a decisoi probelm is the problem that answers "yes" whenever the original problem answers "no" and answers "no" whenever the original problem answers "yes",>>>>if we found an ordinary deterministic polynomial time algorithm for a problem we would have a deterministic polynomial time algorithm for its complementary problem finding a polynomial time nondeterministic algorithm for a problem does not automatically produce a polynomial time nondeterministic algorithm for its complementary that is showing that one is in NP does not automatically show that theother is in NP no one has ever shown that the complementary problem to any known NP complete problems is in NP on the other hand no one has ever proven that some problem is in NP whereas its complementary problem isnt in NP the following result has been obtained Theorem: if the complementary to any NP complete problem is in NP the complementary problem to every problem in NP is in NP};
        //public enum The Primes Problem Properites { given a positive integer n whether its prime,>>>>there is a polynomial algorithm for it,>>>>its in NP and its complement is in NP };
        //public enum Polynomial Time Turing Reducibility Properties {we generalize noation of polynomial time many one reduction to nondecision probelm with following definition if problem A can be solved in poynomial time using a hypothetical polynomial time algorithm for problem B then problem A is polynomial time turing reducible to problem B we write A~(T)B this definition does not require that a polynomial time algorithm for problem B exist it only says that if one did exist problem A would also be solvable in polynomial time ,>>>>if A and B are both decision probelms then A~B implies A~(T)B };
        //public enum Set NP Hard Properties { a problem B is called NP Hard if for some NP Complete problem A A polynomial time turing reduces to B A~(T)B,>>>>because Turing reductions are transitive all problems in NP reduce to any NP Hard problem so if a polynomialtime algorithm exists for any NP-hard probelm then P=NP ,>>>>what problems are NP-hard?every NP complete problem is NP Hard and since if we have a polynomial-time algorithm for optimization probelm when we will have one for decision problem so the optimization problem corresponding to any NP Complete problem is NP Hard e.g. for traveling salesperson suppose we have a hypothetical polynoial -time algorithm then for aolsing traveling slaes perosn deciiosn probelm we solve its optimization problem with our hypotetical algorithm to obtain solution mindist then our answer for instance of deciion probelm would be "no" if d<=mindist and "yes" otherwise so our optimization problem along with this extra step gives answer to decision problem so Traveling Salesperson Deciiosn Problem ~(T) Traveling Salesperson Optimization problem,>>>>what probelms are not NP-hard?we dont know if there is any such problem indeed if we were to prove that some problem was not NP Hard we would be proving that P!=NP because if P=NP all NP probelms has a polynomial time algorithm so we solve each probelm in NP by calling hypotical polynomialtime algorithm for any probelm B by calling polynomial algorithm for each probelm  we even dont need algorithm for B so all probelms will be NP-hard on the othe hand any problem for which we have found a polynomial time algorithm may not be NP Hard otherwise P=NP becasue then we have an actual rather than a hypothetical polynomail-time algorithm for some NP-hard probelm so we can solve each probelm in NP in polynomial time using Turing reduction from probelm to NP-hard problem so to illustrate how the set of NP-hard problems fits into the set of all probelms we have that for set of all probelms we have a subset NP-hard and a subset of ut to be NP-complete ,>>>>if a problem is NP Hard its atleast as hard in terms of our hopes of finding a polynomial time algorithm as the NP Complete problems,>>>>to solve these problems one way is using backtrackiong and branch and bound which suffice for a large instance of interest also using Montecalso estimation can be used to determine efficiency for a particular instanceif its efficeint we uase taht algorithm another way is to find an algorithm that is efficient for a subclass of instances of an NP Hrad problem for example a Bayesian network consisits of a directed acyclic graph and a probablity distribution polynomialtime agorithms have been found for subcalss of instances  that are singly connected and the third way is to develope approximation algorithms};
        //public enum Set NP Easy Problem Propeties {we know that NP-hard probelm are at least as hard as NP-complete ones but are NP-complete peobelms at least as hard as NP-hard ones NP-hardness does not imply it so we need this definition: a problem is called NP Easy if for some problem B in NP A polynomial Time Turing Reduces to B A~(T)B ,>>>>clearly if P=NP then a polynomail-time algorithm exists for all NPeasy probelms alsoits defiition is not symmetric with our definition of NP-hard also a probelm is NP-easy iff it reduces to an NP-complete probelm>>>>what probelms are NP-easy?the problems in P theproblems in NP and nondecision problems for which we have found polynomial time algorithms are all NP Easy and the optimization problem corresponding to an NP complete decision problem can usually be shown to be NP Easy ,>>>>if a problem is not in NP its not NP easy so presburger and the halting problem are not NP Easy};
        //public enum Traveling Salesperson Extension Decision Problem Properties { if we have an instance of the traveling Salesperson Decision Problem where number of vertices in the graph is n and the integer is d furthermore let a partial tour T consisting of m distinct vertices be given the problem is todetermine whether T can be extended to a complete tour having total weight no greater than d parameters for this problem are the same as those for traveling salesperson decision probelm plus partial tour T,>>>>we know that traveling salespersonextension decision probelm is in NP so to obtain our desired result we need only show that Traveling Slaesperson Optimization probelm ~(T)Traveling Salesman Extension Decision problem assume polyalg be a hypothetical polynomial-time algorithm for Extensio probelm assume dmin=n and dmax =n*maximum 1<=i,j<=n (weight on edge from v to vj) if mindist is total weight of the edges in an optimal tour then dmin<=mindist<=dmax so having call polyalg(G,[v1],d) smallest value for true return is d=dmin  and if there is a tour return true has d-dmax if it returns false for d=dmax mindist = infinity so by binary search we find smallest value of dfor polyalg returning true and [v1] as input computing mindist in plynomial time as time lg(dmax) so to construct a tour we say a parital tour is extndible if it can be extended to a tour having total weight equal to mindistso finding vi such that [v1,vi] is exyensible we determine such a vi by calling polyalg at most n-2 times as follows:polyalg(G,[v1,vi],mindist)we stop when i reaches n-1 so with an extendibale partial tour containing m vertices we can find one with m+1 vertices in at most n-m-1 calls to polygon so we build an optimal tour following this number of calls (n-2)+..+(n-m-1)+...+1=(n-2)(n-1)/2 so we can also construct an optimal tour in polynomial time and we have a polynomial-time Turing reduction we can construct an optimal tour in polynomial time and we a polynomial time turing reduction };
        //public enum Set NP Equivalent Properties { a problem is called NP Equivalent if it is both NP Hard and NP Easy clearly P=NP iff polynomial-time algorithms exist for all NP-equivalent problems,>>>>the optimization problems corresponding to an NP Complete deciiosn probelm is NP Equivalent this means that finding a polynomial time algorithm for the optimization problem is equivalent to finding one for a deciiosn problem so restricting to decision problems causes no subtantial loss};
        //public enum Approximation Algorithm Properties { for NP Hard optimization problem is an algorithm that is not guaranteed to give optimal solutions but rather yeild solutions that are reasonably close to optimal often we can obtain a bound that gives a guarantee as to bow close a solution is to being optimal e.g. for a variant of travelingsalesperson problem we derive an approximation algorithm with a solution called minapprox we show taht minapprox<2*mindist where mindist is the optimal solutionit does not mean minapprox is alsomt twist middist  may be they are close or equal rather this means we are guaranteed minapprox will never be as great as twice mindist}; 
    }
}
